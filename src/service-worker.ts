/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

interface SyncEvent extends Event {
  readonly tag: string;
  waitUntil(f: Promise<void>): void;
}

interface Mutation {
  id: number;
  status: string;
  timestamp: number;
  syncedAt?: number;
  [key: string]: unknown;
}

// Take control of all pages immediately
clientsClaim();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache Convex API requests with NetworkFirst strategy
// This ensures we try the network first, but fall back to cache when offline
registerRoute(
  ({ url }) => url.origin === "https://api.convex.dev" || url.origin.includes(".convex.cloud"),
  new NetworkFirst({
    cacheName: "convex-api",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  }),
);

// Cache static assets (images, fonts, etc.) with CacheFirst strategy
registerRoute(
  ({ request }) =>
    request.destination === "image" ||
    request.destination === "font" ||
    request.destination === "style",
  new CacheFirst({
    cacheName: "static-assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  }),
);

// Cache JavaScript and CSS with StaleWhileRevalidate
registerRoute(
  ({ request }) => request.destination === "script" || request.destination === "style",
  new StaleWhileRevalidate({
    cacheName: "js-css-assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  }),
);

// Handle offline fallback
self.addEventListener("fetch", (event) => {
  // Only handle GET requests
  if (event.request.method !== "GET") {
    return;
  }

  event.respondWith(
    fetch(event.request).catch(() => {
      // If fetch fails and we're requesting a page, return offline page
      if (event.request.mode === "navigate") {
        return caches.match("/offline.html").then((response) => response || Response.error());
      }
      return Response.error();
    }),
  );
});

// Listen for messages from the client
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }

  if (event.data && event.data.type === "SYNC_QUEUE") {
    // Trigger background sync
    event.waitUntil(syncOfflineQueue());
  }
});

// Background sync for offline mutations
self.addEventListener("sync", (event) => {
  const syncEvent = event as SyncEvent;
  if (syncEvent.tag === "sync-mutations") {
    syncEvent.waitUntil(syncOfflineQueue());
  }
});

async function syncOfflineQueue() {
  try {
    // Get pending mutations from IndexedDB
    const db = await openDB();
    const mutations = await getAllPendingMutations(db);

    for (const mutation of mutations) {
      try {
        // Send mutation to server
        await fetch("/api/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(mutation),
        });

        // Mark as synced
        await markMutationSynced(db, mutation.id);
      } catch {
        // Individual mutation sync errors are logged but don't stop the sync
      }
    }
  } catch {
    // Background sync errors are non-critical
  }
}

// IndexedDB helpers
function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("NixeloOfflineDB", 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;

      // Create object stores
      if (!db.objectStoreNames.contains("mutations")) {
        const store = db.createObjectStore("mutations", {
          keyPath: "id",
          autoIncrement: true,
        });
        store.createIndex("status", "status", { unique: false });
        store.createIndex("timestamp", "timestamp", { unique: false });
      }

      if (!db.objectStoreNames.contains("cachedData")) {
        const store = db.createObjectStore("cachedData", { keyPath: "key" });
        store.createIndex("timestamp", "timestamp", { unique: false });
      }
    };
  });
}

function getAllPendingMutations(db: IDBDatabase): Promise<Mutation[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(["mutations"], "readonly");
    const store = transaction.objectStore("mutations");
    const index = store.index("status");
    const request = index.getAll("pending");

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function markMutationSynced(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(["mutations"], "readwrite");
    const store = transaction.objectStore("mutations");
    const request = store.get(id);

    request.onsuccess = () => {
      const mutation = request.result;
      if (mutation) {
        mutation.status = "synced";
        mutation.syncedAt = Date.now();
        store.put(mutation);
      }
    };

    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(transaction.error);
  });
}

// Notify clients when new version is available
self.addEventListener("install", (event) => {
  // Force the waiting service worker to become the active service worker
  event.waitUntil(self.skipWaiting());
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches
        .keys()
        .then((cacheNames) => {
          return Promise.all(
            cacheNames
              .filter((cacheName) => {
                // Delete old caches
                return (
                  cacheName.startsWith("convex-") ||
                  cacheName.startsWith("static-") ||
                  cacheName.startsWith("js-css-")
                );
              })
              .map((cacheName) => caches.delete(cacheName)),
          );
        }),
      // Take control of all pages
      self.clients.claim(),
    ]),
  );
});
