# RULES.md - Development Rules & Conventions

> **Last Updated:** 2026-01-30

Generic development rules and conventions for AI assistants. Project-specific details are in CLAUDE.md.

## HARD RULES (NO EXCEPTIONS)

- **NEVER** add "Co-Authored-By", "Generated by", or any AI attribution to commits
- **NEVER** use `>/dev/null`, `2>/dev/null`, `2>nul`, or any null redirect (creates junk `nul` files on Windows)
- **NEVER** commit secrets or credentials
- **NEVER** update the git config

---

## TypeScript Rules

### Strict Type Safety

- Use strict type checking (enabled in tsconfig)
- Prefer explicit types for function parameters
- Use generated types from framework (Convex, Prisma, etc.)

### Forbidden Patterns

```typescript
// ❌ FORBIDDEN - any type
function process(data: any) {}

// ✅ CORRECT - specific types or unknown with guards
function process(data: unknown) {
  if (typeof data === 'object' && data !== null && 'id' in data) {
    // Type guard ensures safety
  }
}
```

```typescript
// ❌ FORBIDDEN - type assertions for convenience
const user = req.body as User;

// ✅ CORRECT - type guards
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj;
}
if (isUser(body)) {
  const user: User = body;
}
```

### Required Practices

1. **Explicit types for function parameters** — always type arguments
2. **Return types** — add explicit return types for exported/public functions. Omit for React components (JSX inference) and Convex handlers (framework inference).
3. **Proper error handling** with typed catches
4. **No `@ts-ignore` or `@ts-nocheck`** — fix the actual issues
5. **No `biome-ignore`** unless absolutely necessary with justification

---

## Code Style

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Components | PascalCase | `DocumentEditor.tsx` |
| Utilities | camelCase | `formatDate.ts` |
| Constants | UPPER_SNAKE_CASE | `API_ENDPOINTS` |
| Functions | camelCase | `createDocument()` |
| Types/Interfaces | PascalCase | `interface UserProfile` |

### Import Organization

Imports should be sorted in this order:
1. Node.js built-ins (`node:fs`, `path`)
2. External packages (`react`, `lodash`)
3. Internal packages (`@/components`, `@repo/ui`)
4. Parent imports (`../utils`)
5. Sibling imports (`./helper`)
6. Style imports (`*.css`)

### Tailwind Arbitrary Values

- **NEVER** use arbitrary bracket syntax (`w-[Npx]`, `max-h-[Xvh]`) for values
  used in more than one place. Define a design token in `src/index.css` `@theme`
  block instead.
- **Check `src/index.css` `@theme` block** for existing tokens before reaching
  for arbitrary values. Also check `constants.ts` for JS-side constants.
- The validator (`scripts/validate/check-arbitrary-tw.js`) flags all arbitrary
  values. If you genuinely need one, add it to the `ALLOWED_PATTERNS` allowlist
  with a comment explaining why.

### Semantic Color System

- **NEVER** use raw Tailwind colors (`bg-blue-500`, `text-gray-700`). Use semantic tokens: `bg-brand`, `text-ui-text-secondary`, `border-status-error`.
- **NEVER** use hardcoded hex/rgb values in className or inline styles. All colors go through the token system in `src/index.css`.
- Dark mode is automatic via `light-dark()` in semantic tokens — never add `dark:` variants for semantic color classes.

### Export Patterns

```typescript
// ✅ CORRECT - Named exports for components
export function ComponentName(props: Props) {
  return <div>...</div>;
}

// ❌ INCORRECT - Default exports
export default function ComponentName() {}
```

---

## Git & Version Control

- **NEVER** commit unless explicitly asked
- **NEVER** push to remote unless explicitly asked
- **NEVER** use git commands with `-i` flag (interactive mode not supported)
- **NEVER** use `--amend` unless explicitly asked
- If no changes to commit, do not create an empty commit
- Use descriptive commit messages focusing on "why" not "what"

---

## File Management

- **NEVER** create files unless absolutely necessary
- **ALWAYS** prefer editing existing files over creating new ones
- **NEVER** proactively create documentation files (*.md, README) unless asked
- Avoid deleting node_modules directories without reason

---

## Testing Rules

### General Approach

- Write tests alongside code (`.spec.ts` or `.test.ts` files)
- This project uses **Vitest** (not Jest) for unit tests and **Playwright** for E2E
- Run tests before committing significant changes

### Playwright/E2E Testing

**Selector priority** (most preferred → least preferred):
1. Accessible selectors: `getByRole`, `getByLabel`, `getByText`
2. Test IDs from shared constants: `getByTestId(TEST_IDS.ISSUE.CARD)`
3. Data attributes: `locator("[data-tour='sidebar']")`
4. Scoped CSS selectors (on a container, not `page`)

```typescript
// ✅ CORRECT - Accessible selectors
await page.getByRole('button', { name: /submit/i });
await page.getByLabel('Email');
await page.getByTestId(TEST_IDS.ISSUE.CARD);

// ❌ WRONG - Raw selectors, unscoped, deprecated patterns
await page.waitForSelector('[data-testid="..."]');
await page.waitForLoadState('networkidle');
await page.locator("img").first();         // Matches any <img> on page
await page.locator(".animate-pulse");       // Generic CSS class
await page.getByTestId("issue-card");       // Raw string — use TEST_IDS constant
```

### Test ID Constants

All `data-testid` values must use constants from `src/lib/test-ids.ts` — both in components and E2E tests. The `check-test-ids.js` validator enforces this in CI.

```typescript
// In components:
import { TEST_IDS } from "@/lib/test-ids";
<div data-testid={TEST_IDS.ACTIVITY.FEED}>

// In E2E tests:
import { TEST_IDS } from "../src/lib/test-ids";
page.getByTestId(TEST_IDS.ACTIVITY.FEED);
```

### E2E Anti-Patterns (enforced by `check-e2e-quality.js`)

| Pattern | Problem | Fix |
|---------|---------|-----|
| `page.locator("img").first()` | Matches any `<img>` on page | Scope to container or use `getByRole` |
| `page.locator(".animate-pulse")` | Generic CSS class | Wait for specific content to appear instead |
| `page.waitForSelector(...)` | Deprecated Playwright API | Use `locator().waitFor()` or `expect(locator).toBeVisible()` |
| `waitForLoadState("networkidle")` | Flaky, unreliable timing | Wait for a specific element assertion |
| `getByTestId("raw-string")` | Breaks if ID changes | Use `TEST_IDS.SECTION.ELEMENT` constant |

### Scoping Selectors

Always scope child queries to a container instead of searching the entire page:

```typescript
// ✅ CORRECT - Scoped to feed container
const feed = page.getByTestId(TEST_IDS.ACTIVITY.FEED);
const entry = feed.getByTestId(TEST_IDS.ACTIVITY.ENTRY).first();
await expect(entry.getByText(/created/i)).toBeVisible();

// ❌ WRONG - Unscoped page queries
const entry = page.getByText(/created/i).first(); // Could match anything
```

---

## Package Manager

- Use **pnpm** for all package management (unless project specifies otherwise)
- Use `pnpm` instead of `npm`
- **NEVER** use `npx` directly — stdout is swallowed in nvm4w + Git Bash
- **NOTE**: `pnpm run` also swallows stdout in Claude Code's Git Bash environment
- For typecheck/biome, use direct node commands: `node node_modules/<pkg>/bin/<cli>`
- Always check package.json for available scripts before guessing

---

## CRITICAL: Output Verification & Silent Failures

### The Problem

Shell shims (`pnpm`, `npm`, `npx`, `.bin/*`) use `exec` which breaks stdout capture in Windows/Git Bash environments. Commands appear to succeed (exit code 0) but produce NO OUTPUT.

### HARD RULES

1. **Empty output is NEVER success** — If a command that should produce output returns nothing, this is a CRITICAL FAILURE. Stop and investigate immediately.

2. **Truncated output is a RED FLAG** — If output appears cut off, re-run with different approach before proceeding.

3. **MUST see actual verification** — Before claiming tests/lint passed:
   - Tests: Must see "X passed, Y failed" or equivalent
   - Lint: Must see error count or "no issues"
   - TypeScript: Must see "Found 0 errors" or actual error list
   - Validator: Must see "RESULT: PASS" or actual error list
   - If you can't see this output, YOU DON'T KNOW IF IT PASSED

4. **When output fails, use direct node**:
   ```bash
   # Instead of: pnpm test
   node node_modules/vitest/vitest.mjs

   # Instead of: pnpm biome check
   node node_modules/@biomejs/biome/bin/biome check

   # Instead of: pnpm tsc
   node node_modules/typescript/bin/tsc

   # Custom validator (always use directly)
   node scripts/validate.js
   ```

5. **NEVER push without verified output** — If you cannot get command output working, STOP and tell the user. Do not assume success.

### Response Protocol

When output is empty or cut:
```
CRITICAL: Command produced no output. This is NOT success.
- Command: [what you ran]
- Expected: [what output should look like]
- Action: Investigating with direct node invocation...
```

---

## "Make it WORK" not "Make it PASS"

### FORBIDDEN Shortcuts

- Deleting tests to make CI pass
- Adding `@ts-ignore` to hide type errors
- Using `any` to bypass type checking
- Suppressing lint rules without fixing underlying issue
- Assuming empty output means success

### Required Approach

- Understand WHY an error occurs before fixing
- Fix the root cause, not the symptom
- If a test is truly obsolete, explain WHY before deleting
- If you can't fix it, tell the user — don't hide it

---

## Code Quality

### Before Writing Code

1. **Read the file first** — never propose changes to code you haven't read
2. **Match existing patterns** in the file you're editing
3. **Check surrounding context** especially imports
4. **Verify library usage** in existing codebase

### After Making Changes

1. After completing a significant chunk of work (new feature, multi-file refactor, major bug fix), run `pnpm fixme` to auto-fix lint/format issues and typecheck. Do NOT run after every small edit.
2. Run `node scripts/validate.js` after UI changes — target 0 errors, 0 warnings.
3. Run tests if applicable
4. If unable to find correct command, ask

### Avoid Over-Engineering

- Only make changes that are directly requested or clearly necessary
- Don't add features, refactor code, or make "improvements" beyond what was asked
- Don't add docstrings, comments, or type annotations to code you didn't change
- Don't add error handling for scenarios that can't happen
- Don't create helpers or abstractions for one-time operations

---

## Security

- **ALWAYS** validate user input at system boundaries
- **NEVER** expose or log secrets and keys
- Check authentication in every mutation/query
- Throw errors for unauthorized access
- Use framework validators for runtime type safety

---

## Communication

- Focus on specific requests
- Provide honest technical feedback
- Challenge questionable approaches and suggest better alternatives
- Don't use excessive praise or validation
