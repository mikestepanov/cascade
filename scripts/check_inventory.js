import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const RESEARCH_ROOT = path.resolve(__dirname, "../docs/research");
const COMPETITORS_DOCS = path.join(RESEARCH_ROOT, "competitors");
const LIBRARY_DIR = path.join(RESEARCH_ROOT, "library");

// 1. Scan Analysis Docs (Markdown files)
function scanAnalysisDocs(dir, fileList = []) {
  if (!fs.existsSync(dir)) return fileList;
  const files = fs.readdirSync(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    if (stat.isDirectory()) {
      scanAnalysisDocs(fullPath, fileList);
    } else if (file.endsWith(".md") && !file.toLowerCase().includes("readme")) {
      // Extract competitor name from filename (e.g., "linear.md" -> "linear")
      const name = path.basename(file, ".md").toLowerCase();
      fileList.push({ name, path: fullPath });
    }
  }
  return fileList;
}

// 2. Scan Library (Scraped Data folders)
function scanLibrary() {
  if (!fs.existsSync(LIBRARY_DIR)) return [];
  return fs
    .readdirSync(LIBRARY_DIR)
    .map((name) => {
      const dir = path.join(LIBRARY_DIR, name);
      if (!fs.statSync(dir).isDirectory()) return null;

      // Count assets
      const files = fs.readdirSync(dir);
      const hasHtml = files.some((f) => f.endsWith(".html"));
      const hasDeepJson = files.some((f) => f.endsWith("_deep.json"));
      const hasAssets = fs.existsSync(path.join(dir, "assets"));

      return {
        name: name.toLowerCase(),
        hasHtml,
        hasDeepJson,
        hasAssets,
      };
    })
    .filter(Boolean);
}

function generateStatusIcon(bool) {
  return bool ? "‚úÖ" : "‚ùå";
}

function main() {
  console.log("üîç Scanning Research Inventory...");

  const analysisDocs = scanAnalysisDocs(COMPETITORS_DOCS);
  const libraryData = scanLibrary();

  // Merge lists
  const allCompetitors = new Set([
    ...analysisDocs.map((d) => d.name),
    ...libraryData.map((l) => l.name),
  ]);

  const matrix = [];

  for (const comp of Array.from(allCompetitors).sort()) {
    const doc = analysisDocs.find((d) => d.name === comp);
    const lib = libraryData.find((l) => l.name === comp);

    // Determine category based on doc path if available
    let category = "Unknown";
    if (doc) {
      if (doc.path.includes("pm-suites")) category = "PM Suites";
      else if (doc.path.includes("meeting-ai")) category = "Meeting AI";
      else if (doc.path.includes("time-tracking")) category = "Time Tracking";
      else if (doc.path.includes("infrastructure")) category = "Infrastructure";
      else if (doc.path.includes("open-source")) category = "Open Source";
    }

    matrix.push({
      competitor: comp.charAt(0).toUpperCase() + comp.slice(1),
      category,
      hasDoc: !!doc,
      docPath: doc ? path.relative(RESEARCH_ROOT, doc.path).replace(/\\/g, "/") : null,
      scraped: !!lib,
      deepData: lib ? lib.hasDeepJson : false,
      assets: lib ? lib.hasAssets : false,
    });
  }

  // Generate Markdown Table
  let md = "# üìä Live Research Inventory\n\n";
  md += `**Last Updated:** ${new Date().toISOString().split("T")[0]}\n\n`;
  md += "| Competitor | Category | Analysis Doc | Scraped Data | Deep Metadata | Assets |\n";
  md += "| :--- | :--- | :---: | :---: | :---: | :---: |\n";

  for (const row of matrix) {
    const docLink = row.hasDoc ? `[View](${row.docPath})` : "‚ùå Missing";
    const scraped = generateStatusIcon(row.scraped);
    const deep = generateStatusIcon(row.deepData);
    const assets = generateStatusIcon(row.assets);

    md += `| **${row.competitor}** | ${row.category} | ${docLink} | ${scraped} | ${deep} | ${assets} |\n`;
  }

  md += "\n---\n\n*Generated by `scripts/check_inventory.js`*";

  // Write to INVENTORY.md
  fs.writeFileSync(path.join(RESEARCH_ROOT, "INVENTORY.md"), md);
  console.log("‚úÖ Updated docs/research/INVENTORY.md");
}

main();
